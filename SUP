#pragma config(Sensor, S1,     Touch_Sensor,   sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra_Sensor,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     Gyro_Sensor,    sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S4,     Touch1_Sensor,   sensorEV3_Touch)
#pragma config(Motor,  motorA,          Right_Motor,   tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          Left_Motor,    tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------------



// Start in cell [0][0]
int StartPosRow=3;
int StartPosCol=5;

//Robot direction
int RobotDirection=0;  //N=0, E=1, S=2, W=3;

//Set starting position
int CurrentPosRow=StartPosRow; // Starting position
int CurrentPosCol=StartPosCol;

//Set target cell
int TargetPosRow=0;
int TargetPosCol=0;

//const int ScreenWidth = 177;
//const int ScreenHeight = 127;
//--------------------------------------------------------

//Initiate functions

void Backup();

void RecordStraight();
void RecordLeftTurn();
void RecordRightTurn();

void MoveRobotStraight();
void MoveRobotLeft();
void MoveRobotRight();

void Solve1();
void Bump();


//======================================================*

task main()
{
	while(true){

		if(SensorValue(Touch_Sensor)==1)
		{
			playTone(300,200);
			sleep(2000);

			while((CurrentPosRow!=TargetPosRow)&&(CurrentPosCol!=TargetPosCol)){

				Solve1();
			}
			playTone(300,200);
		}
	}
}

//======================================================*

void Backup(){
	//Back up from wall
	resetMotorEncoder(Right_Motor); resetMotorEncoder(Left_Motor);
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, 215, 30);
	while (getMotorEncoder(Right_Motor) < start1 + 215) {
		sleep(1);
	}
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
	waitUntilMotorStop(Left_Motor);

}


//--------------------------------------------------------

void RecordStraight(){

	switch(RobotDirection){
		//Store position in variable
	case 0:
		CurrentPosRow++; //Robot move north
		break;

	case 1:
		CurrentPosCol++; //Robot move east
		break;

	case 2:
		CurrentPosRow--; //Robot move west
		break;

	case 3:
		CurrentPosCol--; //Robot face south
		break;

	default:
		break;
	}
}

void RecordLeftTurn(){

	//Alter direction variable
	RobotDirection=RobotDirection--;

	//Keeps direction stored within bounds
	if(RobotDirection==-1){
		RobotDirection=3;

	}
}

void RecordRightTurn(){

	//Alter direction variable
	RobotDirection=RobotDirection++;

	//Keeps direction stored within bounds
	if(RobotDirection==4){
		RobotDirection=0;

	}
}

//--------------------------------------------------------

void MoveRobotStraight(){
	//Move straight one cell


	long start1 = getMotorEncoder(Left_Motor);

	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, -600, -30);
	while (getMotorEncoder(Left_Motor) > start1 - 600) {
		sleep(1);
	}
	motor[Left_Motor]=motor[Right_Motor]=0;


	if(SensorValue(Touch1_Sensor)==1)
	{
		Bump();
	}else
	{
		RecordStraight();
	}
}

void MoveRobotLeft(){

	//Turn robot90 degrees left
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor,Right_Motor,100, -206, -25);
	while (getMotorEncoder(Left_Motor) < start1 + 206) {
		sleep(1);
	}
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
	sleep(100);

	RecordLeftTurn();
}

void MoveRobotRight(){
	//Turn robot 90 degrees right
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor,Right_Motor,100, 206, 30);
	while (getMotorEncoder(Left_Motor) > start1 - 206) {
		sleep(1);
	}
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
	sleep(100);

	RecordRightTurn();
}

//-----------------------------------------------------


void Bump(){
	Backup();

	MoveRobotRight();
}

void Solve1(){

	if(getUSDistance(Ultra_Sensor)>=10){//if wall=false
		MoveRobotLeft();
		MoveRobotStraight();
	}
	else if(getUSDistance(Ultra_Sensor)<10){
		MoveRobotStraight();
	}

}
