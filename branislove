#pragma config(Sensor, S1,     Touch_Sensor,   sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra_Sensor,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     Gyro_Sensor,    sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S4,     Touch1_Sensor,   sensorEV3_Touch)
#pragma config(Motor,  motorA,          Right_Motor,   tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          Left_Motor,    tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------------



// Start in cell [0][0]
int StartPosRow=0;
int StartPosCol=0;

//Robot direction
int RobotDirection=0;  //N=0, E=1, S=2, W=3;

//Set starting position
int CurrentPosRow=StartPosRow; // Starting position
int CurrentPosCol=StartPosCol;

//Set target cell
int TargetPosRow=3;
int TargetPosCol=5;

//const int ScreenWidth = 177;
//const int ScreenHeight = 127;

int OFFSET = -5;
//--------------------------------------------------------

//Initiate functions

void Backup();

void RecordStraight();


void MoveRobotStraight();
void MoveRobotLeft();
void MoveRobotRight();

void Solve1();
void Bump();


//======================================================*

task main()
{
	//Reset motors
	setMotorBrakeMode(Left_Motor,motorCoast);
	setMotorBrakeMode(Right_Motor,motorCoast);
	resetMotorEncoder(Left_Motor);
	resetMotorEncoder(Right_Motor);
	resetGyro(Gyro_Sensor);
	getGyroDegrees(Gyro_Sensor);

	while(true){
		//Starts program when touch sensor is activated
		if(SensorValue(Touch_Sensor)==1)
		{
			//Play 300 Hz tone for 2 seconds
			playTone(300,200);
			sleep(2000);

			//Solves while current position =/= target position
			while((CurrentPosRow!=TargetPosRow)&&(CurrentPosCol!=TargetPosCol)){

				Solve1();
			}
			//Play 300 Hz tone for 2 seconds
			playTone(300,200);
		}
	}
}

//======================================================*

void Backup(){
	//Backs up from wall
	sleep(100);
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, 210, 30);
	while (getMotorEncoder(Right_Motor) < start1 + 210) {
		sleep(1);
	}
	//Stop motors
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
}


//--------------------------------------------------------

void RecordStraight(){

	//Records the change of position using its relative direction
	switch(RobotDirection){
	case 0: CurrentPosRow++; break; // Facing North
	case 1: CurrentPosCol++; break; // Facing East
	case 2: CurrentPosRow--; break; // Facing South
	case 3: CurrentPosCol--; break; // Facing West
	default: break;
	}
}

//--------------------------------------------------------

void MoveRobotStraight(){

	//Move straight one cell

	//Reset motor encoder
	resetMotorEncoder(Left_Motor);
	resetMotorEncoder(Right_Motor);

	//Move robot as long as touch sensor is not activated
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, -620, -30);
	while (getMotorEncoder(Left_Motor) > start1 - 620 && SensorValue(Touch_Sensor)==0) {
		sleep(1);
	}
	//Stop Robot
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;

	if(SensorValue(Touch_Sensor)==1)
	{
		//Start Bump function
		Bump();
	}
	else{
		//Record
		RecordStraight();
	}
}

void MoveRobotLeft(){

//Reset motor encoder and gyro
	resetMotorEncoder(Left_Motor);
	resetMotorEncoder(Right_Motor);
	resetGyro(Gyro_Sensor);

	//Turn robot90 degrees left
	setMotorSpeed(Left_Motor, 30);
	setMotorSpeed(Right_Motor, -30);
	long target=getGyroDegrees(Gyro_Sensor);
	while (getGyroDegrees(Gyro_Sensor) > target-abs(90+OFFSET)) {
		sleep(1);
	}
	motor[Left_Motor]=0;
	motor[Right_Motor]=0;

	//Alter direction variable
	RobotDirection--;
	//Keeps direction stored within bounds
	if(RobotDirection==-1){
		RobotDirection=3;

	}
}

void MoveRobotRight(){

//Reset motor encoder and gyro
	resetMotorEncoder(Left_Motor);
	resetMotorEncoder(Right_Motor);
	resetGyro(Gyro_Sensor);

	//Turn robot 90 degrees right
	setMotorSpeed(Left_Motor, -30);
	setMotorSpeed(Right_Motor, 30);
	long target=getGyroDegrees(Gyro_Sensor);
	while (getGyroDegrees(Gyro_Sensor) < target+abs(90+OFFSET)) {
		sleep(1);
	}

	//Stop motors
	motor[Left_Motor]=0;
	motor[Right_Motor]=0;

	//Alter direction variable
	RobotDirection++;
	//Keeps direction stored within bounds
	if(RobotDirection==4){
		RobotDirection=0;

	}
}

//-----------------------------------------------------


void Bump(){
	//Backs up and turns left
	Backup();
	MoveRobotLeft();

	//Move straight unless the touch sensor
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, -620, -30);
	while (getMotorEncoder(Left_Motor) > start1 - 620 && SensorValue(Touch_Sensor)==0) {
		sleep(1);
	}
	//Stop motors
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;

	//Checks for bump
	if(SensorValue(Touch_Sensor)==1)
	{
		//detect bump again -> deadend
		Backup();
		MoveRobotLeft();
		long start1 = getMotorEncoder(Left_Motor);
		setMotorSyncEncoder(Left_Motor, Right_Motor, 0, -620, -30);
		while (getMotorEncoder(Left_Motor) > start1 - 620 && SensorValue(Touch_Sensor)==0) {
			sleep(1);
		}
		motor[Left_Motor] = 0;
		motor[Right_Motor] = 0;
		RecordStraight();
	}
	else{
		//If no bump record straight move
		RecordStraight();
	}
}

void Solve1(){

	if(getUSDistance(Ultra_Sensor)>=10){//if wall=false
		MoveRobotRight();
		MoveRobotStraight();
	}
	else if(getUSDistance(Ultra_Sensor)<10){//if wall=true
		MoveRobotStraight();
	}
}

//int retrace(){
