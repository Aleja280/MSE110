#pragma config(Sensor, S1,     Touch_Sensor,   sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra_Sensor,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     Gyro_Sensor,    sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          Right_Motor,   tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          Left_Motor,    tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------------


typedef struct {
	int NorthWall;
	int EastWall;
	int SoutWall;
	int WestWall;
	char status;
} cell;

cell grid[4][6];


// Start in cell [0][0]
int StartPosRow=0;
int StartPosCol=0;

//Robot direction
int RobotDirection=0;  //N=0, E=1, S=2, W=3;

//Set starting position
int CurrentPosRow=StartPosRow; // Starting position
int CurrentPosCol=StartPosCol;

//Set target cell
int TargetPosRow=3;
int TargetPosCol=5;

const int ScreenWidth = 177;
const int ScreenHeight = 127;
//--------------------------------------------------------

//Initiate functions

void DisplayStartandEnd();
void GoStraight();
void GoLeft();
void GoRight();
int Solver();
int CheckWall();
void Bump();


//======================================================*

task main()
{
	if(getUSDistance(Ultra_Sensor){


	}
}

//======================================================*


void Bump(){
	
	GoRight();
	GoStraight();
}

int CheckWall(){

	int WallStatus=0; // 0 = No Wall, 1= Wall

	switch(RobotDirection){

	case 0:
		if(Grid[CurrentPosRow][CurrentPosCol].NorthWall==1){
			WallStatus=1;
		}
		else{
			WallStatus=0; // exit the CheckWall function, Indicate Wall
		}
		break;
	case 1:
		if(Grid[CurrentPosRow][CurrentPosCol].EastWall==1){
			WallStatus=1;
		}
		else{
			WallStatus=0; // exit the CheckWall function, Indicate Wall
		}
		break;
	case 2:
		if(Grid[CurrentPosRow][CurrentPosCol].SouthWall==1){
			WallStatus=1;
		}
		else{
			WallStatus=0; // exit the CheckWall function, Indicate Wall
		}
		break;
	case 3:
		if(Grid[CurrentPosRow][CurrentPosCol].WestWall==1){
			WallStatus=1;
		}
		else{
			WallStatus=0; // exit the CheckWall function, Indicate Wall
		}
		break;
	default: break;
	}
	return WallStatus;
}

//--------------------------------------------------------

void RecordStraight(){

	switch(RobotDirection){
		//Store position in variable
	case 0:
		CurrentPosRow++; //Robot move north
		break;

	case 1:
		CurrentPosCol++; //Robot move east
		break;

	case 2:
		CurrentPosRow--; //Robot move west
		break;

	case 3:
		CurrentPosCol--; //Robot face south
		break;

	default:
		break;
	}
}

void RecordLeft(){

	//Alter direction variable
	RobotDirection=RobotDirection--;

	//Keeps direction stored within bounds
	if(RobotDirection==-1){
		RobotDirection=3;

	}
}

void RecordRight(){

	//Alter direction variable
	RobotDirection=RobotDirection++;

	//Keeps direction stored within bounds
	if(RobotDirection==4){
		RobotDirection=0;

	}
}

//--------------------------------------------------------

void MoveRobotStraight(){
	//Move straight one cell
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, -598, -30);
	while (getMotorEncoder(Right_Motor) > start1 - 598 && SensorValue(Touch_Sensor)==0) {
		sleep(1);
	}
	else if(SensorValue(Touch_Sensor)==1)
	{
		Bump();
		break;
	}
	
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
	RecordStraight();
}

void MoveRobotLeft(){

	//Turn robot90 degrees left
	setMotorSyncEncoder(Left_Motor,Right_Motor,-100, 2000, 40);
	long target=getGyroDegrees(Gyro_Sensor)-52;
	while (getGyroDegrees(Gyro_Sensor) > target) {
		sleep(1);
	}
	RecordLeft();
}

void MoveRobotRight(){
	//Turn robot 90 degrees right
	setMotorSyncEncoder(Left_Motor,Right_Motor,100, 2000, 40);
	long target=getGyroDegrees(Gyro_Sensor)+52;
	while (getGyroDegrees(Gyro_Sensor) < target) {
		sleep(1);
	}
	RecordRight();
}

//-----------------------------------------------------


void AlterLeftWall(){

	int WallStatus=0;

	switch(RobotDirection){

	case 0://Face north
		Grid[CurrentPosRow][CurrentPosCol] .WestWall=1;
		break;

	case 1://Face east
		Grid[CurrentPosRow][CurrentPosCol] .NorthWall=1;
		break;

	case 2://Face south
		Grid[CurrentPosRow][CurrentPosCol] .EastWall=1;
		break

	case 3://Face west
		Grid[CurrentPosRow][CurrentPosCol] .SouthWall=1;
		break;
	}

	//--------------------------------------------------------

	int Solver(){
		if(getSensorValue(Ultrasensor)<=10)//if wall=true
		{
			AlterLeftWall();
			GoStraight();
		}
		else
		{
			GoLeft();
			GoStraight();
		}

		//--------------------------------------------------------
		//int CheckWall(){
		//	int WallStatus=0; // 0 = No Wall, 1= Wall

		//	switch(RobotDirection){
		//	case 0:
		//		if(Grid[CurrentPosRow][CurrentPosCol].NorthWall==1){
		//			WallStatus=1;
		//		}
		//		else{
		//			WallStatus=0; // exit the CheckWall function, Indicate Wall
		//		}
		//		break;
		//	case 1:
		//		if(Grid[CurrentPosRow][CurrentPosCol].EastWall==1){
		//			WallStatus=1;
		//		}
		//		else{
		//			WallStatus=0; // exit the CheckWall function, Indicate Wall
		//		}
		//		break;
		//	case 2:
		//		if(Grid[CurrentPosRow][CurrentPosCol].SouthWall==1){
		//			WallStatus=1;
		//		}
		//		else{
		//			WallStatus=0; // exit the CheckWall function, Indicate Wall
		//		}
		//		break;
		//	case 3:
		//		if(Grid[CurrentPosRow][CurrentPosCol].WestWall==1){
		//			WallStatus=1;
		//		}
		//		else{
		//			WallStatus=0; // exit the CheckWall function, Indicate Wall
		//		}
		//		break;
		//	default: break;
		//	}
		//	return WallStatus;
		//}
		//----------------------------------------------------------------
		void DisplayStartandEnd(){
			int XpixelPos=0;
			int YpixelPos=0;

			if(StartPosCol==0){
				XpixelPos=ScreenWidth/12;
			}
			else{
				XpixelPos=(2*StartPosCol+1)*ScreenWidth/12;
			}

			if(StartPosRow==0){
				YpixelPos=ScreenHeight/8;
			}
			else{
				YpixelPos=(2*StartPosRow+1)*ScreenHeight/8;
			}
			displayStringAt(XpixelPos,YpixelPos,"S");

			if(TargetPosCol==0){
				XpixelPos=ScreenWidth/12;
			}
			else{
				XpixelPos=(2*TargetPosCol+1)*ScreenWidth/12;
			}

			if(TargetPosRow==0){
				YpixelPos=ScreenHeight/8;
			}
			else{
				YpixelPos=(2*TargetPosRow+1)*ScreenHeight/8;
			}
			displayStringAt(XpixelPos,YpixelPos,"E");
		}
