#pragma config(Sensor, S1,     Touch_Sensor,   sensorEV3_Touch)
#pragma config(Sensor, S2,     Ultra_Sensor,   sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     Gyro_Sensor,    sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Motor,  motorA,          Right_Motor,   tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          Left_Motor,    tmotorEV3_Large, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//--------------------------------------------------------


typedef struct {
	int NorthWall;
	int EastWall;
	int SouthWall;
	int WestWall;
	char status;
} Cell;

Cell Grid[4][6];


// Start in cell [0][0]
int StartPosRow=0;
int StartPosCol=0;

//Robot direction
int RobotDirection=0;  //N=0, E=1, S=2, W=3;

//Set starting position
int CurrentPosRow=StartPosRow; // Starting position
int CurrentPosCol=StartPosCol;

//Set target cell
int TargetPosRow=3;
int TargetPosCol=5;

//const int ScreenWidth = 177;
//const int ScreenHeight = 127;
//--------------------------------------------------------

//Initiate functions

void GridInit();
void Backup();

void RecordStraight();
void RecordLeft();
void RecordRight();

void MoveRobotStraight();
void MoveRobotLeft();
void MoveRobotRight();

void Solver();
void Bump();


//======================================================*

task main()
{
	while(true){

		if(SensorValue(Touch_Sensor)==1)
		{
			playTone(300,200);
			sleep(2000);
			GridInit();
			while((CurrentPosRow!=TargetPosRow)&&(CurrentPosCol!=TargetPosCol)){
				Solver();
			}
			playTone(300,200);
		}

	}
}

//======================================================*

void GridInit(){
	for(int i=0;i<4;i++){
		for(int j=0;j<6;j++){
			Grid[i][j].NorthWall=0;
			Grid[i][j].EastWall=0;
			Grid[i][j].WestWall=0;
			Grid[i][j].SouthWall=0;
		}
	}
}
//=====================================================
void Backup(){
	//Back up from wall
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, 200, 30);
	while (getMotorEncoder(Right_Motor) < start1 + 200) {
		sleep(1);
	}
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
}


//--------------------------------------------------------

void RecordStraight(){

	switch(RobotDirection){
		//Store position in variable
	case 0:
		CurrentPosRow++; //Robot move north
		break;

	case 1:
		CurrentPosCol++; //Robot move east
		break;

	case 2:
		CurrentPosRow--; //Robot move west
		break;

	case 3:
		CurrentPosCol--; //Robot face south
		break;

	default:
		break;
	}
}

void RecordLeft(){

	//Alter direction variable
	RobotDirection=RobotDirection--;

	//Keeps direction stored within bounds
	if(RobotDirection==-1){
		RobotDirection=3;

	}
}

void RecordRight(){

	//Alter direction variable
	RobotDirection=RobotDirection++;

	//Keeps direction stored within bounds
	if(RobotDirection==4){
		RobotDirection=0;

	}
}

//--------------------------------------------------------

void MoveRobotStraight(){
	//Move straight one cell

	resetBumpedValue(Touch_Sensor);
	
resetMotorEncoder(Left_Motor);

	long start1 = getMotorEncoder(Left_Motor);
                                            
	setMotorSyncEncoder(Left_Motor, Right_Motor, 0, -598, -30);
	while (getMotorEncoder(Left_Motor) > start1 - 598 && SensorValue(Touch_Sensor)==0) {
		sleep(1);
	}
	if(SensorValue(Touch_Sensor)==1)
	{
		Bump();
	}

	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;
	if(getBumpedValue(Touch_Sensor)==1)
	{

		RecordStraight();
	}
}

void MoveRobotLeft(){

	//Turn robot90 degrees left
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor,Right_Motor,100, -211, -25);
	while (getMotorEncoder(Left_Motor) < start1 + 211) {
		sleep(1);
	}
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;

	RecordLeft();
}

void MoveRobotRight(){
	//Turn robot 90 degrees right
	long start1 = getMotorEncoder(Left_Motor);
	setMotorSyncEncoder(Left_Motor,Right_Motor,100, 211, 30);
	while (getMotorEncoder(Left_Motor) > start1 - 211) {
		sleep(1);
	}
	motor[Left_Motor] = 0;
	motor[Right_Motor] = 0;

	RecordRight();
}

//-----------------------------------------------------


void RecordLeftWall(){


	switch(RobotDirection){

	case 0://Face north
		Grid[CurrentPosRow][CurrentPosCol] .WestWall=1;
		break;

	case 1://Face east
		Grid[CurrentPosRow][CurrentPosCol] .NorthWall=1;
		break;

	case 2://Face south
		Grid[CurrentPosRow][CurrentPosCol] .EastWall=1;
		break;

	case 3://Face west
		Grid[CurrentPosRow][CurrentPosCol] .SouthWall =1;
		break;
	}
}



void RecordFrontWall(){

	switch(RobotDirection){

	case 0://Face north
		Grid[CurrentPosRow][CurrentPosCol] .NorthWall=1;
		break;

	case 1://Face east
		Grid[CurrentPosRow][CurrentPosCol] .EastWall=1;
		break;

	case 2://Face south
		Grid[CurrentPosRow][CurrentPosCol] .SouthWall=1;
		break;

	case 3://Face west
		Grid[CurrentPosRow][CurrentPosCol] .WestWall=1;
		break;
	}

}


void Bump(){
	Backup();
	RecordFrontWall();
	MoveRobotRight();
}

//--------------------------------------------------------

void Solver(){

	if(getUSDistance(Ultra_Sensor)<=10){//if wall=true
		RecordLeftWall();
		MoveRobotStraight();
	}
	else
	{
		MoveRobotLeft();
		MoveRobotStraight();
	}

}
//--------------------------------------------------------
//int CheckWall(){
//	int WallStatus=0; // 0 = No Wall, 1= Wall

//	switch(RobotDirection){
//	case 0:
//		if(Grid[CurrentPosRow][CurrentPosCol].NorthWall==1){
//			WallStatus=1;
//		}
//		else{
//			WallStatus=0; // exit the CheckWall function, Indicate Wall
//		}
//		break;
//	case 1:
//		if(Grid[CurrentPosRow][CurrentPosCol].EastWall==1){
//			WallStatus=1;
//		}
//		else{
//			WallStatus=0; // exit the CheckWall function, Indicate Wall
//		}
//		break;
//	case 2:
//		if(Grid[CurrentPosRow][CurrentPosCol].SouthWall==1){
//			WallStatus=1;
//		}
//		else{
//			WallStatus=0; // exit the CheckWall function, Indicate Wall
//		}
//		break;
//	case 3:
//		if(Grid[CurrentPosRow][CurrentPosCol].WestWall==1){
//			WallStatus=1;
//		}
//		else{
//			WallStatus=0; // exit the CheckWall function, Indicate Wall
//		}
//		break;
//	default: break;
//	}
//	return WallStatus;
//}
//----------------------------------------------------------------
//void DisplayStartandEnd(){
//	int XpixelPos=0;
//	int YpixelPos=0;

//	if(StartPosCol==0){
//		XpixelPos=ScreenWidth/12;
//	}
//	else{
//		XpixelPos=(2*StartPosCol+1)*ScreenWidth/12;
//	}

//	if(StartPosRow==0){
//		YpixelPos=ScreenHeight/8;
//	}
//	else{
//		YpixelPos=(2*StartPosRow+1)*ScreenHeight/8;
//	}
//	displayStringAt(XpixelPos,YpixelPos,"S");

//	if(TargetPosCol==0){
//		XpixelPos=ScreenWidth/12;
//	}
//	else{
//		XpixelPos=(2*TargetPosCol+1)*ScreenWidth/12;
//	}

//	if(TargetPosRow==0){
//		YpixelPos=ScreenHeight/8;
//	}
//	else{
//		YpixelPos=(2*TargetPosRow+1)*ScreenHeight/8;
//	}
//	displayStringAt(XpixelPos,YpixelPos,"E");
//}
