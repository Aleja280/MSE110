#pragma config(Sensor, S1,     Gyro_Sensor,    sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S2,     Light_Sensor,   sensorEV3_Color)
#pragma config(Sensor, S3,     Ultra_Sensor,   sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          Left_Motor,    tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          Right_Motor,   tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

double Left_pos;
double Right_pos;
double Light_grade;
double Error;
double Middle_point;
double Integral;
double Derivative;
double Last_error;
double Kp;
double Ki;
double Kd;
double Tp;
double Turn;
long Left_power;
long Right_power;

task main()
{
	Kp=180;
	Ki=0;
	Kd=0;
	Tp=25;
	Middle_point=34;
	
	setMotorBrakeMode(Left_Motor,motorBrake);
	setMotorBrakeMode(Right_Motor,motorBrake);
	resetMotorEncoder(Left_Motor);
	resetMotorEncoder(Right_Motor);
	resetGyro(Gyro_Sensor);


	while(true){

		Left_pos = getMotorEncoder(Left_Motor);
		displayStringAt(4,20, "%d",Left_pos);
		Right_pos = getMotorEncoder(Right_Motor);
		displayStringAt(4,50, "%d",Right_pos);
		
		while(getUSDistance(Ultra_Sensor)>10){

			Light_grade = getColorReflected(Light_Sensor);
			Error = Light_grade - Middle_point;
			Integral = Integral + Error;
			Derivative = Error - Last_error;
			Turn=Kp*Error+Ki*Integral+Kd*Derivative;

			Left_power=Tp-Turn;
			Right_power=Tp+Turn;
			motor[motorB]=Left_power;
			motor[motorC]=Right_power;
			Last_error=Error;
		}

		if(getUSDistance(Ultra_Sensor)<=10){
		//Wait 2 sec then beep`
			motor[Left_Motor]=0;
			motor[Right_Motor]=0;
			playSound(soundBeepBeep);
			delay(2000);
			//left turn
			setMotorSyncEncoder(Left_Motor,Right_Motor,-100, 2000, 20);
			long target=getGyroDegrees(Gyro_Sensor)-90;
			while (getGyroDegrees(Gyro_Sensor) > target) {
				sleep(1);
			}
			motor[Left_Motor] = 0;
			motor[Right_Motor] = 0;

			//go straight
			long start1 = getMotorEncoder(Left_Motor);
			setMotorSyncEncoder(Left_Motor, Right_Motor, 0, 350, 40);
			while (getMotorEncoder(Left_Motor) < start1 + 350) {
				sleep(1);
			}
			motor[Left_Motor] = 0;
			motor[Right_Motor] = 0;
			//right turn
			setMotorSyncEncoder(Left_Motor,Right_Motor,100, 2000, 20);
			target=getGyroDegrees(Gyro_Sensor)+90;
			while (getGyroDegrees(Gyro_Sensor) < target) {
				sleep(1);
			}
			motor[Left_Motor] = 0;
			motor[Right_Motor] = 0;
			//go straight
			start1 = getMotorEncoder(Left_Motor);
			setMotorSyncEncoder(Left_Motor,Right_Motor,0,900,40);
			while(getMotorEncoder(Left_Motor)< start1 + 900) {
				sleep(1);
			}
			motor[Left_Motor]=0;
			motor[Right_Motor]=0;
			//right turn
			setMotorSyncEncoder(Left_Motor,Right_Motor,100, 2000, 20);
			target=getGyroDegrees(Gyro_Sensor)+90;
			while (getGyroDegrees(Gyro_Sensor) < target) {
				sleep(1);
			}

			motor[Left_Motor] = 0;
			motor[Right_Motor] = 0;
			//go straight
			start1=getMotorEncoder(Left_Motor);
			setMotorSyncEncoder(Left_Motor,Right_Motor,0,350,40);
			while(getMotorEncoder(Left_Motor)< start1 + 350){
				sleep(1);
			}

			motor[Left_Motor]=0;
			motor[Right_Motor]=0;
			//go straight

			//turn left
			setMotorSyncEncoder(Left_Motor,Right_Motor,-100, 2000, 20);
			target=getGyroDegrees(Gyro_Sensor)-90;
			while (getGyroDegrees(Gyro_Sensor) > target) {
				sleep(1);
			}
			motor[Left_Motor] = 0;
			motor[Right_Motor] = 0;
		}

	}
}
